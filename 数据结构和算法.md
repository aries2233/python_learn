# 数据结构和算法

抽象：抽出问题的特征，忽略非本质的细节

## 算法：是解决特点问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作

基本特性：输入、输出、有穷性、确定性、可行性

算法设计要求：正确性、可读性、健壮性、时间效率高和存储量低

事前分析估算方法

### 时间复杂度

1.用1取代加法常数

2.只保留最高阶

3.若最高阶系数不是1，则去除该系数

空间复杂度

### 线性表：零个或多个数据元素的有限序列

线性表的顺序存储结构：指用一段地址连续的存储单元依次存储线性表的数据元素

链式存储结构：

#### 单链表

​	时间上-查找慢，方便插入和删除

​	空间上-不需要分配存储空间

#### 静态链表

​	插入和删除时只需要修改游标，不需要移动元素

​	失去了顺序存储结构随机存取（直接存取）的特性

​	没有解决表长难以确认的问题

#### 循环链表

​	应用：约瑟夫环

https://blog.csdn.net/cj1561435010/article/details/104459053?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167820715716800184112815%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167820715716800184112815&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104459053-null-null.142^v73^pc_new_rank,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8&spm=1018.2226.3001.4187

#### 双向链表

​	比单链表更方便删除自身结点



### 栈与队列

栈：限定仅在表尾进行插入或删除操作的线性表（进栈、出栈）

#### 两栈共享空间：

栈满：top1 + 1 = top2

进栈：top1++ top2--

出栈：top1-- top2++

#### 链栈

栈顶放在单链表头部

#### 栈的应用：递归

#### 栈的应用：四则运算表达式求值

中缀表达式->后缀表达式

输出数字，符号进栈；右括号或优先级不高于栈顶符号则栈顶元素依次出栈并输出，当前符号进栈

后缀表达式->结果

数字进栈，遇到符号将处于栈顶两个数字出栈并运算，结果进栈



#### 队列：只允许一段插入，另一端删除

#### 循环队列：

通过front指针指向队头元素和rear指针指向队尾元素的下一个位置。

当front=rear时，为空队列

推理得

#### (rear+1)%size==front

计算队列长度公式为

#### (rear-front+size)%size

#### 链队列



### 串：由零个或多个字符组成的有限序列，又叫字符串

串中的字符数目n成为串的长度

空串

空格串

包含子串的串称为主串

#### 朴素的模式匹配算法：逐个匹配 O((n-m+1)*m)

#### KMP模式匹配算法

通过比较前缀和后缀提高查找的速度

next值推导：

前缀与后缀的重复数量+1

O(n+m)

#### KMP模式匹配算法的改进

nextval值推导：

当j=x时，next值为N，第x个字符与第N个字符是否相等

若相等，则nextval[x]=nextval[N]

若不相等，则nextval[x]=N



### 树：n个结点的有限集

定义：根唯一，子树不相交

度：结点的子树个数

度为0：叶结点、终端结点

树的度：各结点的度的最大值

孩子、双亲、兄弟

结点层次

树中结点的最大层次称为树的深度

### 森林：m棵互不相交的树的集合



#### 存储结构：

##### 双亲长子表示法

data parent firstchild

parent firstchild均为下标

根结点双亲为-1



##### 双亲孩子表示法

表头数组：储存表头结点

表头结点：data parent firstchild

firstchild存储该结点的孩子链表的头指针

孩子链表：child next

child存储表头数组的下标，next指向下一个孩子



##### 双亲孩子兄弟表示法

data parent firstchild rightsib



### 二叉树

特点：最多两棵子树，有顺序。

特殊二叉树：

斜树：只有左孩子或右孩子

满二叉树：叶子全在下一层，非叶子结点一定是2

完全二叉树：数据全部靠左

#### 二叉树的性质：

1. 第i层最多2^(i-1)个结点

2. 深度为k的二叉树至少有2^k -1个结点

3. 终端结点为n0，度为2的结点为n2，则n0=n2+1

4. 具有n个结点的<u>完全二叉树</u>的深度为[log2 n]+1（[x]表示不大于x的最大整数）

5. 对一棵有n个结点的<u>完全二叉树</u>，按层序编号，对任意结点i有：

   如果i=1，则i为根，无双亲

   如果i>1，则双亲为[i/2]

   如果2i>n，则结点无左孩子，否则左孩子为2i

   如果2i+1>n则结点无右孩子，否则右孩子为2i+1



##### 二叉树的顺序存储结构

A^C^^FG^IJ

##### 二叉链表

lchild data rchild



#### 二叉树的遍历

前序遍历

双亲->左孩子->右孩子

中序遍历

左孩子->双亲->右孩子

后序遍历

左孩子->右孩子->双亲



#### 线索二叉树

将二叉树转换为双向链表

lchild ltag data rtag rchild

当tag=0时，指向孩子，当=1时，指向前驱或后继



#### 树->二叉树

1）加线。在所有兄弟之间加一条连线。

2）去线。只保留每个结点与第一个孩子的连线。

3）层次调整。第一个孩子是二叉树结点的左孩子，其他兄弟是右孩子



森林->二叉树

1）把每棵树转换为二叉树

2）把后一棵二叉树的根结点作为前一棵二叉树的右孩子，用线连起来



#### 二叉树->树

1）加线。某个结点的左孩子的n个右孩子都作为该结点的孩子

2）去线。删除所有结点与其右孩子结点的连线

3）层次调整



#### 二叉树->森林

根结点有无右孩子

有->森林 没有->树

1）从根结点开始，若右孩子存在，则把与右孩子结点的连线删除

2）直到根结点所有右孩子全部分离

3）将分离后的二叉树转换为树



##### 树的遍历

前序遍历，后序遍历

##### 森林的遍历

前序遍历，后序遍历（但是是中序遍历的算法）



### 哈夫曼树

路径长度：从一个结点到另一个结点之间的分支数目

树的路径长度：树根到每一个结点的路径长度之和

带权路径长度：结点上的权*路径长度

树的带权路径长度

带权路径长度WPL最小的二叉树称为哈夫曼树

构造方法：

1）选取权重最小的树作为左右字数构造一棵新的二叉树，且根结点的权值为左右子树权值之和

2）把该新二叉树也放到权重队列中，重复该过程，直到剩余一棵二叉树



## 图：由顶点的有穷非空集合和顶点之间的边的集合组成

## G(V,E)  V为顶点集合，E为边集合

边集可以是空

无向边：没有方向，(Vi,Vj)

有向边：称作弧，有方向，<Vi,Vj>，由弧尾指向弧头

无向完全图：(n*(n-1))/2条边

有向完全图：n*(n-1)条边

稀疏图，稠密图

网：带权的图

子图

无向图：v1与v2互为邻接点，边(v1,v2)依附于v1,v2，顶点v的度是和v相关联的边的数目

有向图：以v为头的弧的数目为入度，以v为尾的弧的数目为出度。顶点v的度=入度+出度

路径：一个顶点序列

路径的长度是路径上的边的数目

回路或环：第一个顶点和最后一个顶点相同的路径

简单路径：顶点不重复出现

简单回路/简单环：除第一个顶点和最后一个顶点外，其他顶点不重复出现的回路

如v1到v2有路径，则称v1和v2是连通的

对于G图中任意两个顶点都是联通的，则称G是连通图

无向图中的极大联通子图称为连通分量

在有向图中，对任意两点均存在路径，则G为强连通图

有向图中的极大强连通子图称为有向图的强连通分量

### 生成树

一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。

如果一个有向图恰有一个顶点的入度为0，其余顶点入度为1，则是一个有向树

一个有向图的生成森林由若干棵有向树组成，含有图中的全部顶点，只有足以构成若干棵不相交的有向树的弧

### 存储结构

#### 邻接矩阵

顶点数组：一维数组，存储定点信息v0,v1,v2

邻接矩阵：二维数组，存储图中的边的信息

|      | v0   | v1   | v2   |
| ---- | ---- | ---- | ---- |
| v0   | 0    | 1    | 1    |
| v1   | 1    | 0    | 1    |
| v2   | 1    | 1    | 0    |

对角线：主对象线，为0

无向图的边数组是对称矩阵



有向图

​                                          弧头

|      | v0   | v1   | v2   |
| ---- | ---- | ---- | ---- |
| v0   | 0    | 0    | 0    |
| v1   | 1    | 0    | 1    |
| v2   | 1    | 1    | 0    |

弧尾

弧尾->弧头

入度：列之和

出度：行之和

##### 对于网

以∞取代没有邻接

```c
typedef struct
{
  类型 vexs[100];/*顶点数组*/
  类型 arc[100][100];/*邻接矩阵*/
  int numNodes,numEdges; /*顶点数，边数*/
};
```



### 领接表：对每个顶点vi建立一个链接为vi为弧尾的表

用一维数组存储顶点

每个数据元素存储指向第一个邻接点的指针

data firstedge -> adjvex (weight) next

逆邻接表：对每个顶点vi建立一个链接为vi为弧头的表

邻接表的创建：运用头插法



### 十字链表

将邻接表和逆邻接表结合起来

data firstin firstout -> tailevex headvex headlink taillink



### 邻接多重表

data firstedge ->ivex ilink jvex jlink

ivex和jvex是与某条边依附的两个顶点在顶点表中的下标

ilink指向ivex的下一条边

jink指向jvex的下一条边

注意ilink指向的结点的jvex一定要和它本身的ivex的值相同



### 边集数组

由两个一维数组构成

一个存储顶点的信息

一个存储边的信息

边数组：begin end weight



### 图的遍历

#### 深度优先遍历DFS

类似树的前序遍历

从图中某个顶点出发，访问此顶点，然后从该顶点的未被访问的邻接点出发深度优先遍历图，直到图中所有和v有路径相通的顶点都被访问到。

若图中有顶点未被访问，则另选图中一个未曾被访问的顶点作始点，重复上述过程，直到所有顶点都被访问为止。

#### 广度优先遍历BFS

类似树的层序遍历



### 最小生成树

构造连通网的最小代价生成树

n个顶点用n-1条边把一个连通图连接起来，使得权值之和最小

#### 普里姆算法

适合稠密图

每次找出距离生成树最近的顶点，将其纳入生成树中，直至包含所有顶点

#### 克鲁斯卡尔算法

适合稀疏图

每次寻找权值最小的边，直到所有顶点构成一个连通分量



### 最短路径

对于网图来说，最短路径是指两顶点之间经过的边上权值之和最少的路径，并且记路径第一个顶点为源点，最后一个是顶点

#### 迪杰斯特拉算法

#### 弗洛伊德算法



### 拓扑排序

在一个工程有向图中，用顶点表示活动，用弧表示活动之间的联系的活动的网称为AOV

拓扑序列不止一条



### 关键路径

用顶点表示事件，用有向边表示活动，用边上的权值表示活动的时间的活动的网称为AOE

各个活动所持续时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动

