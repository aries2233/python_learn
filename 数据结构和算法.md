# 数据结构和算法

抽象：抽出问题的特征，忽略非本质的细节

## 算法：是解决特点问题求解步骤的描述，在计算机中表现为指令的优先序列，并且每条指令表示一个或多个操作

基本特性：输入、输出、有穷性、确定性、可行性

算法设计要求：正确性、可读性、健壮性、时间效率高和存储量低

事前分析估算方法

### 时间复杂度

1.用1取代加法常数

2.只保留最高阶

3.若最高阶系数不是1，则去除该系数

空间复杂度

### 线性表：零个或多个数据元素的有限序列

线性表的顺序存储结构：指用一段地址连续的存储单元依次存储线性表的数据元素

链式存储结构：

#### 单链表

​	时间上-查找慢，方便插入和删除

​	空间上-不需要分配存储空间

#### 静态链表

​	插入和删除时只需要修改游标，不需要移动元素

​	失去了顺序存储结构随机存取（直接存取）的特性

​	没有解决表长难以确认的问题

#### 循环链表

​	应用：约瑟夫环

https://blog.csdn.net/cj1561435010/article/details/104459053?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167820715716800184112815%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167820715716800184112815&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104459053-null-null.142^v73^pc_new_rank,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8&spm=1018.2226.3001.4187

#### 双向链表

​	比单链表更方便删除自身结点



### 栈与队列

栈：限定仅在表尾进行插入或删除操作的线性表（进栈、出栈）

#### 两栈共享空间：

栈满：top1 + 1 = top2

进栈：top1++ top2--

出栈：top1-- top2++

#### 链栈

栈顶放在单链表头部

#### 栈的应用：递归

#### 栈的应用：四则运算表达式求值

中缀表达式->后缀表达式

输出数字，符号进栈；右括号或优先级不高于栈顶符号则栈顶元素依次出栈并输出，当前符号进栈

后缀表达式->结果

数字进栈，遇到符号将处于栈顶两个数字出栈并运算，结果进栈



#### 队列：只允许一段插入，另一端删除

#### 循环队列：

通过front指针指向队头元素和rear指针指向队尾元素的下一个位置。

当front=rear时，为空队列

推理得

#### (rear+1)%size==front

计算队列长度公式为

#### (rear-front+size)%size

#### 链队列



### 串：由零个或多个字符组成的有限序列，又叫字符串

串中的字符数目n成为串的长度

空串

空格串

包含子串的串称为主串

#### 朴素的模式匹配算法：逐个匹配 O((n-m+1)*m)

#### KMP模式匹配算法

通过比较前缀和后缀提高查找的速度

next值推导：

前缀与后缀的重复数量+1

O(n+m)

#### KMP模式匹配算法的改进

nextval值推导：

当j=x时，next值为N，第x个字符与第N个字符是否相等

若相等，则nextval[x]=nextval[N]

若不相等，则nextval[x]=N



### 树：n个结点的有限集

定义：根唯一，子树不相交

度：结点的子树个数

度为0：叶结点、终端结点

树的度：各结点的度的最大值

孩子、双亲、兄弟

结点层次

树中结点的最大层次称为树的深度

### 森林：m棵互不相交的树的集合



#### 存储结构：

##### 双亲长子表示法

data parent firstchild

parent firstchild均为下标

根结点双亲为-1



##### 双亲孩子表示法

表头数组：储存表头结点

表头结点：data parent firstchild

firstchild存储该结点的孩子链表的头指针

孩子链表：child next

child存储表头数组的下标，next指向下一个孩子



##### 双亲孩子兄弟表示法

data parent firstchild rightsib



### 二叉树

特点：最多两棵子树，有顺序。

特殊二叉树：

斜树：只有左孩子或右孩子

满二叉树：叶子全在下一层，非叶子结点一定是2

完全二叉树：数据全部靠左

#### 二叉树的性质：

1. 第i层最多2^(i-1)个结点

2. 深度为k的二叉树至少有2^k -1个结点

3. 终端结点为n0，度为2的结点为n2，则n0=n2+1

4. 具有n个结点的<u>完全二叉树</u>的深度为[log2 n]+1（[x]表示不大于x的最大整数）

5. 对一棵有n个结点的<u>完全二叉树</u>，按层序编号，对任意结点i有：

   如果i=1，则i为根，无双亲

   如果i>1，则双亲为[i/2]

   如果2i>n，则结点无左孩子，否则左孩子为2i

   如果2i+1>n则结点无右孩子，否则右孩子为2i+1



##### 二叉树的顺序存储结构

A^C^^FG^IJ

##### 二叉链表

lchild data rchild



#### 二叉树的遍历

前序遍历

双亲->左孩子->右孩子

中序遍历

左孩子->双亲->右孩子

后序遍历

左孩子->右孩子->双亲



#### 线索二叉树

将二叉树转换为双向链表

lchild ltag data rtag rchild

当tag=0时，指向孩子，当=1时，指向前驱或后继



#### 树->二叉树

1）加线。在所有兄弟之间加一条连线。

2）去线。只保留每个结点与第一个孩子的连线。

3）层次调整。第一个孩子是二叉树结点的左孩子，其他兄弟是右孩子



森林->二叉树

1）把每棵树转换为二叉树

2）把后一棵二叉树的根结点作为前一棵二叉树的右孩子，用线连起来



#### 二叉树->树

1）加线。某个结点的左孩子的n个右孩子都作为该结点的孩子

2）去线。删除所有结点与其右孩子结点的连线

3）层次调整



#### 二叉树->森林

根结点有无右孩子

有->森林 没有->树

1）从根结点开始，若右孩子存在，则把与右孩子结点的连线删除

2）直到根结点所有右孩子全部分离

3）将分离后的二叉树转换为树



##### 树的遍历

前序遍历，后序遍历

##### 森林的遍历

前序遍历，后序遍历（但是是中序遍历的算法）



### 哈夫曼树

路径长度：从一个结点到另一个结点之间的分支数目

树的路径长度：树根到每一个结点的路径长度之和

带权路径长度：结点上的权*路径长度

树的带权路径长度

带权路径长度WPL最小的二叉树称为哈夫曼树

构造方法：

1）选取权重最小的树作为左右字数构造一棵新的二叉树，且根结点的权值为左右子树权值之和

2）把该新二叉树也放到权重队列中，重复该过程，直到剩余一棵二叉树

